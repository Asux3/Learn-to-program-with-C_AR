\chapter{المؤشّرات}
لقد حان الوقت لنكتشف المؤشرات. خذ نفسا عميقا قبل أن تقرر قراءة هذا الدرس لأنه لن يكون درساً للهو و المرح. تمثل المؤشرات واحداً من المبادئ الأكثر أهمية و حساسية في لغة الـ
\textenglish{C}
. و إن كنت أصرّ على أهميتها فهذا  لأنه لا يمكنك إالبرمجة بـ
\textenglish{C}
دون معرفتها و فهمها جيّدا. المؤشرات موجودة في كلّ مكان، و لقد استعملتها من قبل دون أن تعلم بذلك.

كثير من المتعلّمين يصلون إلى المؤشرات و يواجهون صعوبات في فهمها. سنعمل على ألا يكون الأمر مماثلا بالنسبة لك. ضاعف التركيز و خذ الوقت اللازم لفهم المخططات التي سأقدمها لك في هذا الفصل.

\section{مشكل مضجر بالفعل}
واحد من أكبر المشاكل مع المؤشرات هي أنّه بالإضافة إلى أنها صعبة الاستيعاب قليلا بالنسبة للمبتدئين، فإن المتعلّم لا يعرف ما هي أهميتها و فيما يمكننا استعمالها.

يمكنني أن أقول لك بأن "المؤشرات لا يمكن الاستغناء عنها في أي برنامج
\textenglish{C}
، صدقني !"، لكنّي أعرف أن هذه الحجّة ليست كافية لك.

سأطرح عليك مشكلاً لا يمكنك حلّه إلا باستخدام المؤشرات. سيكون هذا مقدّمتنا في هذا الفصل. سنعود إليه في نهاية هذا الفصل و سنترون حلّه باستعمال ما تعلّمتموه في هذا الفصل.

إليك المشكل: أريد كتابة دالة تقوم بإرجاع قيمتين مختلفتين. ستجيبني "هذا مستحيل !". بالفعل، الدالة لا يمكنها ارجاع سوى قيمة واحدة.
\begin{Csource}
int function()
{
	return value;
}
\end{Csource}
اذا استخدمنا
\InlineCode{int}
ترجع لنا قيمة من نوع
\InlineCode{int}
(بفضل التعليمة
\InlineCode{return}).

يمكننا ايضا كتابة دالة لا تُرجع اية قيمة باستخدام الكلمة المفتاحية
\InlineCode{void}.
\begin{Csource}
void function()
{

}
\end{Csource}
لكن إرجاع قيمتين مختلفتين في نفس الوقت... هذا أمر مستحيل لأنه لا يمكننا استعمال تعليمتي
\InlineCode{return}.

لنفرض أنني أريد كتابة دالة أعطيها كمدخل عددا من الدقائق. تقوم الدالة بإرجاع عدد الساعات و الدقائق المواقفة لها.
\begin{itemize}
  \item إذا أعطيت القيمة 45  الدالة ترجع 0 ساعة و 45 دقيقة.
  \item إذا أعطيت القيمة 60 الدالة ترجع القيمة  1 ساعة و 0 دقائق.
	\item إذا أعطيت القيمة 90 الدالة ترجع القيمة  1 ساعة و 30 دقائق.
\end{itemize}
نكن مجانين و لنجرّب ذلك :
\begin{Csource}
#include <stdio.h>
#include <stdlib.h>

/* I put the prototype at the top.
Because it's a short code, I don't put it in a .h file.
In a real program I would have put the prototype
in a separate .h file of course */

void minutesDevision(int hours, int minutes);

int main(int argc, char *argv[])
{
	int hours = 0, minutes = 90;

/* We have a variable "minutes" equals to 90.
   after calling the function, I want from the variable
“hours" to take the value 1 and from my variable
"minutes" to take the value 30 */

	minutesDivision(hours, minutes);
	printf("%d hours and %d minutes", hours, minutes);
	return 0;
}

void minutesDevision(int hours, int minutes)
{
	hours = minutes / 60;  // 90 / 60 = 1
	minutes = minutes % 60; // 90 % 60 = 30
}
\end{Csource}
النتيجة :
\begin{Console}
0 hours and 90 minutes
\end{Console}
لم تشتغل ! ما الأمر يا ترى ؟
في الواقع، عندما نبعث متغيرا إلى دالة، يتم إنشاء نسخة من المتغير، و لهذا فالمتغير
\InlineCode{hours}
في الدالة
\InlineCode{minutesDevision}
هو ليس نفسه الذي في الدالة
\InlineCode{main} !
إنه فقط نسخة !

الدالة
\InlineCode{minutesDevision}
تقوم بعملها. ففي داخلها المتغيران
\InlineCode{hours}
و
\InlineCode{minutes}
يحملان القيمتين الصحيحتين : 1 و 30.

لكن بعد ذلك، تتوقف الدالة مباشرة عند الوصول إلى الحاضنة الغالقة، مثلما تعلمنا سابقا: المتغيرات الخاصة بدالة يتم حذفها مباشرة عند انتهاء الدالة. اذن النسخ عن المتغيرات
\InlineCode{minutes}
و
\InlineCode{hours}
تُمسح.
نرجع بعد ذلك للدالة
\InlineCode{main}.
و التي فيها متغيراتنا
\InlineCode{minutes}
و
\InlineCode{hours}
تحملان القيمتين 0 و 90. لقد فشلنا !
\begin{information}
	لاحظ إذن،بما أن الدالة تقوم بنسخ المتغيرات التي نعطيها لها، لست مضطراً لستمية متغيراتك بنفس الأسماء التي تحملها في الـدالة الرئيسية
\InlineCode{main}.
و بالتالي يمكنك ببساطة كتابة :

\InlineCode{void minutesDivision(int h, int m)}\\
\InlineCode{h}
للساعات و
\InlineCode{m}
للدقائق.\\
إن كانت متغيراتك لم تسمّى بنفس الطريقة في الدالة و في
\InlineCode{main}
فهذا لا يطرح أيّ مشكل !
\end{information}


باختصار، يمكنك إعادة المشكل في كلّ الاتجاهات. يمكنك محاولة بعث قيمة باستخدام الدالة (باستخدام
\InlineCode{return}
و باستخدام النوع
\InlineCode{int}
للدالة) ، لكن لا يمكنك إعادة أكثر من قيمة واحدة من بين القيمتين، هذا مشكل مطروح إذن. كما لا يمكنك استعمال متغيرات شاملة لأن هذا أمر غير مستحسن إطلاقا.

حسناً المشكل لازال مطروحاً، كيف يمكننا حلّه باستخدام المؤشرات ؟

\section{الذاكرة، مسألة عنوان}
\subsection{تذكير بالمكتسبات القبليّة}
سأعود بك قليلاً إلى الوراء، هل تتذكر درس المتغيرات ؟

أيّا كانت إجابتك، أنصحك بأن تعود إلى ذلك الفصل و تقرأ منه الجزء الذي يحمل عنوان (مسألة ذاكرة). هناك مخطط مهم جداً سأقترحه عليك من جديد (الصورة الموالية) :
\Picture{Chapter_II-2_RAM-Schema}
هكذا نقوم تقريباً بتمثيل الذاكرة الحية (الرام) الخاصة بالحاسوب.

يجب قراءة المخطط سطراً بسطر، السطر الأول يمثل "الخانة" الخاصة بأول الذاكرة. لكل خانة رقم، هذا الرقم يمثل
\textbf{عنوانها}
(تذكّر هذا المصطلح جيدا). تحتوي الذاكرة على عدد كبير جداً من العناوين تبدأ من الرقم 0 و تنتهي بالرقم
\textit{(ضع رقماً كبيراً جداً هنا)}.
عدد العناوين التي تتوفر عليها تعتمد على حجم الذاكرة التي يحتوي عليها الجهاز الخاص بك.

في كلّ عنوان يمكننا تخزين عدد واحد فقط. لا يمكننا تخزين عددين في نفس العنوان.

الذاكرة ليست مصنوعة سوى لتخزين الأعداد. لا يمكنها تخزين لا حروف و لا جُمل. و للتخلص من هذا المشكل تم اختراع جدول يقوم بالربط بين الحروف و الأعداد. يقول الجدول مثلاً :"العدد 89 يمثّل الحرف
\textenglish{Y}".
سنعود في درس لاحق إلى عملية التحكّم في الحروف. حاليّا، سنتكفي بالتكلّم عن عمل الذاكرة.

\subsection{عنوان و قيمة}
حينما تنشئ متغيراً
\InlineCode{age}
من نوع
\InlineCode{int}
مثلا، بكتابة :
\begin{Csource}
int age = 10;
\end{Csource}
يطلب البرنامج من نظام التشغيل (الويندوز مثلا) الإذن لاستعمال جزء من الذاكرة. نظام التشغيل يجيب بالإشارة إلى أي عنوان سيسمح لك بتخزين العدد.

هنا تكمن أحد أهم وظائف نظام التشغيل : نقول أنه يحجز الذاكرة للبرامج. يمكننا القول أنه هو القائد، يتحكم في كلّ برنامج و يتأكد من أن هذا الأخير له الإذن لاستعمال الذاكرة في المكان الذي يطلبه.
\begin{information}
إن هذا هو السبب الرئيسي في توقف البرامج عن العمل : إذا حاول برنامجك الوصول إلى مكان غير مسموح له بالوصول إليه في الذاكرة، سيرفض نظام التشغيل و يوقف تشغيله بشكل عنيف (لأنه القائد هنا). بينما يتلقّى المستعمل نافذة خطأ تحتوي على رسالة تشير بأن البرنامج يحاول القيام بعملية غير لائقة.
\end{information}
لنعد للمتغير
\InlineCode{age}
. تم تخزين القيمة 10 في مكان ما من الذاكرة، لنقل مثلاً في العنوان رقم 4655.\\
ما يحدث (و هذا دور المترجم) هو أن الكلمة
\InlineCode{age}
يتم تعويضها بالعنوان 4655 لحظة التنفيذ. مما يعني أنه في كلّ مرة قمت فيها بكتابة الكلمة
\InlineCode{age}
في الشفرة المصدرية، يتم تعوضيها بـ4655، و بهذا يرى الجهاز إلى أي عنوان في الذاكرة عليه الذهاب. و منه يجيب بكلّ فخر بأن المتغير
\InlineCode{age}
يحتوي القيمة 10.

نحن نعرف إذا كيف نسترجع قيمة متغير، يكفي بكلّ بساطة أن نكتب الكلمة
\InlineCode{age}
في الشفرة المصدرية. إذا أردنا إظهار السنّ، يمكننا استعمال الدالة
\InlineCode{printf} :
\begin{Csource}
printf("The value of variable age is : %d", age);
\end{Csource}
النتيجة على الشاشة :
\begin{Console}
The value of variable age is : 10
\end{Console}
لا شيء جديد لحدّ الآن.

\subsection{الخبر المثير لليوم}
أنت تعرف كيف تظهر قيمة متغير، لكن هل تعرف أنه بإمكاننا أيضا إظهار عنوانه ؟

لكي نُظهر عنوان متغير، نستعمل الإشارة
\InlineCode{\%p}
(الحرف
\textenglish{p}
مأخوذ من الكلمة
\textenglish{pointer})
في الدالة
\InlineCode{printf}.
أي أننا لن نبعث للدالة
\InlineCode{printf}
المتغير في حدّ ذاته لكن نبعث لها عنوانه. و لفعل هذا، يجب عليك استعمال الإشارة
\InlineCode{\&}
أمام المتغير
\InlineCode{age}
كما طلبت منك أن تفعل مع الدالة
\InlineCode{scanf}
من قبل دون أن أشرح لك لماذا.

أكتب إذا:
\begin{Csource}
printf("The address of the variable age is  : %p", &age);
\end{Csource}
النتيجة :
\begin{Console}
The address of the variable age is : 0023FF74
\end{Console}
ما تراه هنا هو عنوان المتغير
\InlineCode{age}
في اللحظة التي طلبتُ فيها تنفيذ البرنامج من طرف حاسوبي. نعم نعم 0023FF74 هو رقم، هو فقط مكتوب في النظام الست عشري
(\textenglish{hexadecimal})
عوض النظام العشري الذي تعوّدنا عليه. لو تقوم بتعويض
\InlineCode{\%p}
بـ
\InlineCode{\%d}
فإنه سيظهر لك رقما عشريا كما تعوّدنا.
\begin{information}
	إذا شغّلت البرنامج على حاسوبك فمن المؤكّد أن تحصل على عنوان آخر. الأمر يعتمد على المكان في الذاكرة، البرامج المشتغلة، إلخ.
فيستحيل أن تتوقع العنوان الّذي سيتم تخزين المتغيّر فيه.
إذا قمت بتشغيل البرنامج عدة مرات الواحدة تلو الأخرى قد تتحصل على نفس النتيجة كون الذاكرة لم تتغير في ذلك الزمن القصير.
لكن بالمقابل إن أعدت تشغيل الحاسوب فستتحصل بكل تأكيد على نتائج مختلفة.
\end{information}
إلى أين أريد الوصول بكلّ هذا ؟ أريدك أن تتذكّر التالي:
\begin{itemize}
	\item \InlineCode{age} : تعني قيمة المتغير.
	\item \InlineCode{\&age} : تعني عنوان المتغير.
\end{itemize}
عند استخدام
\InlineCode{age}
سيقرأ الحاسوب قيمة المتغيّر في الذاكرة. أمّا عند استخدام
\InlineCode{\&age}
فسيعيد العنوان الذي يوجد فيه المتغيّر.
