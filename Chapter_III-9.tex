\chapter{عمل تطبيقي : الإظهار الطيفي للصوت}

هذا العمل التطبيقي سيقترح عليك التعامل مع الـ\textenglish{SDL}
و الـ\textenglish{FMOD}
في نفس الوقت. هذه المرّة، لن نعمل على لعبة. كما نعرف فالـ\textenglish{SDL}
مخصصة لهذا، لكن يمكن استعمالها في ميادين أخرى. سيقوم هذا الفصل بإثبات أنها صالحة لأجل أشياء أخرى.

سنحقق هنا إظهاراً للطيف الصوتي بالـ\textenglish{SDL}.
يتوقّف هذا على إظهار تركيبة الصوت الذي نشغّله، مثلاً موسيقى. نجد هذه الخاصية في كثير من برامج قراءة الأصوات. إنه أمرٌ ممتع و ليس بقدر الصعوبة التي يبدو عليها !

سيسمح لك هذا الدرس بالعمل على مفاهيم قُمنا باستكشافها مؤخّراً :

\begin{itemize}
	\item التحكّم في الوقت.
	\item المكتبة 
	\textenglish{FMOD}.
\end{itemize}

سنتعرّف علاوة على ذلك، على كيفية التعديل على مساحة بيكسلا ببيكسل.

الصورة التالية تعطيك مظهراً للبرنامج الذي سنكتبه في هذا الفصل.

\Picture{Chapter_III-9_Window-spectral}

هو نوع الإظهار الذي نجده في قارئي الأصوات كـ\textenglish{Winamp}،
\textenglish{Windows Media Player} أو \textenglish{AmaroK}.\\
كما قلتُ لك إن الأمر ليس صعبٌ التحقيق. على عكس العمل التطبيقي الخاص بـ\textenglish{Mario Sokoban}،
هذه المرّة ستقوم بنفسك بالعمل. سيمثّل هذا بالنسبة إليك تمريناً جيداً.

\section{التعليمات}

التعليمات بسيطة. إتّبعها خطوة بخطوة بالترتيب، و لن تواجه أي مشاكل.

\subsection{قراءة ملف \textenglish{MP3}}

لكي تبدأ، يجب عليك إنشاء برنامج يقوم بقراءة ملف
\textenglish{MP3}. ليس عليك سوى إعادة
الأغنية 
"\textenglish{Home}"
للمجموعة
"\textenglish{Hype}"
و التي استعملناها في الفصل الخاص بـ\textenglish{FMOD}
لتلخيص كيفية عمل تشغيل الموسيقى.

إذا اتّبعت جيّدا الفصل حول
\textenglish{FMOD}،
لا تحتاج أكثر من بضعة دقائق لكي تقوم بالعملية. أنصحك بالمناسبة أن تقوم بنقل الملف
\textenglish{MP3}
إلى مجلّد المشروع.

\subsection{استرجاع المعلومات الطيفية للصوت}

لكي نعرف كيف يعمل الإظهار الطيفي للصوت، من الواجب أن أشرح لك كيفية يعمل الأمر من الداخل (بشكل تقريبي فقط، و إلا سندخل في درس رياضيات).

يمكن أن يتم تقسيم الصوت إلى ترددات 
(\textenglish{Frequencies}).
بعض الترددات منخفضة، بعضها متوسطة و بعضها مرتفعة. ما سنقوم به في عملية الإظهار هو إظهار كمية كلّ واحدة من الترددات على شكل شرائط و كلّما يكون الشريط كبيراً، كلما يكون التردد مستعملاً أكثر :

\Picture{Chapter_III-9_Frequencies}

على يسار النافذة، نقوم بإظهار الترددات المنخفضة، و على اليمين الترددات المرتفعة.

\begin{question}
لكن كيف نسترجع كميّة كلّ تردد ؟
\end{question}

ستهتم
\textenglish{FMOD}
بهذا العمل. يمكننا استدعاء الدالة
\InlineCode{FMOD\_Channel\_GetSpectrum}
ذات النموذج :

\begin{Csource}
FMOD_RESULT FMOD_Channel_GetSpectrum(
	FMOD_CHANNEL *  channel,
	float *  spectrumarray,
	int  numvalues,
	int  channeloffset,
	FMOD_DSP_FFT_WINDOW  windowtype
);
\end{Csource}

و هاهي المعاملات التي تحتاجها الدالة :

\begin{itemize}
	\item القناة التي تشتغل فيها الموسيقى. يجب إذا استرجاع مؤشّر نحو هذه القناة.
	\item جدول
	\InlineCode{float}.
	يجب أن يتم حجز الذاكرة من أجل هذا الجدول مسبّقاً، بشكل ثابت أو حيّ، لكي نسمح لـ\textenglish{FMOD}
	بملئه بشكل صحيح.
	\item حجم الجدول. يجب أن يكون حجم الجدول إجبارياً عبارة عن قوّة للعدد 2، مثلا 512.
	\item يسمح هذا المعامل بتعريف بأي مخرج نحن مهتمون. مثلاً لو أننا في
	\textenglish{stereo}،
	فـ$ 0 $ تعني اليسار و $ 1 $ تعني اليمين.
	\item هذا المعامل معقّد قليلاً، و لا يهمّنا حقيقة في هذا الدرس. سنكتفي بإعطائه القيمة\\ 
	\InlineCode{FMOD\_DSP\_FFT\_WINDOW\_RECT}.
\end{itemize}

\begin{information}
تذكير : النوع
\InlineCode{float}
هو نوع عشري، مثل
\InlineCode{double}.
الإختلاف بين الإثنين يكمن في كون الـ\InlineCode{double}
أكثر دقّة من الآخر، لكن في حالتنا يكفينا الـ\InlineCode{float}.
هذا الأخير مستعمل من طرف
\textenglish{FMOD}
هنا. و لذلك، هو ما سنستعمله نحن أيضاً.
\end{information}

بشكل واضح، نعرّف جدول الـ\InlineCode{float} :

\begin{Csource}
float spectrum[512];
\end{Csource}

ثم، حين يتم تشغيل الموسيقى، نطلب من 
\textenglish{FMOD}
ملئ جدول الأطياف بالقيام مثلاً بـ :

\begin{Csource}
FMOD_Channel_GetSpectrum(channel, spectrum, 512, 0, FMOD_DSP_FFT_WINDOW_RECT);
\end{Csource}

يمكننا بعد ذلك تصفّح الجدول لكي نتحصّل على قيم الأطياف :

\begin{Csource}
spectrum[0] // The lowest frequency (Left)
spectrum[1]
spectrum[2]
...
spectrum[509]
spectrum[510]
spectrum[511] // The highest frequency (Right)
\end{Csource}

كلّ تردد هو عبارة عن عدد عشري محصور بين $ 0 $ (لا شيء) و $ 1 $ (قيمة قصوى). ينصّ عملك على إظهار كلّ شريط سواء كان قصيراً أو كبيراً بدلالة القيمة التي تحتويها كلّ من خانات الجدول.

مثلاً، إذا كانت القيمة هي $ 0.5 $ يجدر بك رسم شريط يكون علّوه مساوياً لنصف علوّ النافذة. إذا كانت القيمة هي $ 1 $، فسيأخذ الشريط كلّ علو النافذة.

بشكل عام، تكون القيم ضعيفة (أكثر قرباً من $ 0 $ على $ 1 $). أنصحك بضرب كلّ القيم بـ20 لكي ترى الطيف بشكل أفضل.\\
إحذر : إذا قمت بهذا، تأكد بأنك لن تتجاوز $ 1 $ (قم بتدوير القيمة إلى $ 1 $ إذا احجت إلى ذلك). إذا وجدت أنك تتعامل مع أعداد تفوق $ 1 $، فقد تواجه مشاكل لاحقاً في رسم الشرائط العموديّة لاحقا !

\begin{question}
لكن يجدر بالشرائط أن تتحرّك في نفس الوقت الذي يتم فيه تشغيل الصوت، أليس كذلك ؟ بما أن الصوت يتحرّك كلّ الوقت، يجب تحديث الصورة الرسومية، ما العمل ؟
\end{question}

سؤال جيد. في الواقع، الجدول الخاص المتكون من 
512 \InlineCode{float}
الذي ترجعه لنا
\textenglish{FMOD}
يتغيّر كل 25 مث (لكي نكون في نفس الفاصل الزمني بالنسبة للصوت الحالي). يجب إذا في الشفرة المصدرية أن تعيد قراءة جدول الـ512
\InlineCode{float}
 (بإعادة استدعاء
\InlineCode{FMOD\_Channel\_GetSpectrum}
 كلّ 25 مث)، ثم تقوم بتحديث رسمك ذو الشرائط.
 
أعد قراءة الفصل حول التحكّم في الوقت بالـ\textenglish{SDL}
لكي تتذكّر كيفية عمل ذلك. لديك الخيار بين
\InlineCode{GetTicks}
و الـ\textenglish{callbacks}.
استعمل ما تراه أكثر سهولة لك.

\subsection{إنشاء التدرّج اللوني}

في البداية، يمكنك تحقيق الشرائط بلون موحّد. يمكنك إذا إنشاء مساحات. يجب إذا أن تكون هناك 512 مساحة : واحدة من أجل كلّ شريط. كلّ مساحة تأخذ إذا بيكسلا واحدا كعُرض. و يختلف علوّ الشرائط بدلالة شدّة كلّ تردد.

أنصحك بعدها أن تقوم بتحسين : يجب على الشريط أن يميل للأحمر كلّما زادت كثافة الصوت. أي أنه على الشريط أن يكون أخضراً من الأسفل و أحمراً من الأعلى.

\begin{question}
لكن \dots المساحة الواحدة لا يمكنها أن تأخذ سوى لوناً واحداً لو أننا نستعمل الدالة
\InlineCode{SDL\_FillRect}.
لا يمكننا إنشاء تدرّح لوني !
\end{question}

في الواقع، يمكننا بالتأكيد إنشاء مساحات بعًرض 1 بيكسل و علو 1 بيكسل من أجل كلّ لون في التدرّج. لكن هذا سيأخذ بنا إلى إنشاء مساحات عديدة و لن يكون التحكّم فيها مثالياً !

كيف يمكن لنا أن نرسم بيكسلا ببيكسل ؟\\
لم أعلّمك هذا من قبل، لأنّ هذه التقنية لا تستحقّ فصلاً كاملاً. ستجد أنها في الواقع ليست صعبة. 

في الواقع، لا تقترح الـ\textenglish{SDL}
أية دالة للرسم بيكسلا ببيكسل. لكن لنا الحق في أن نكتبها بأنفسنا. لكي نقوم بهذا، يجب إتّباع هذه الخطوات النموذجية بالترتيب :

\begin{enumerate}
	\item استدع الدالة
	\InlineCode{SDL\_LockSurface}
	لنعلن للـ\textenglish{SDL}
	أننا سنقوم بالتعديل على المساحة يدوياً. هذا "يعطّل" المساحة للـ\textenglish{SDL}
	و ستكون وحدك قادراً على التحكّم فيها مادامت المساحة معطّلة.
	
	هنا، أنصحك بأن تعمل بمساحة واحدة فقط : الشاشة. إذا أردت رسم بيكسل في منطقة محددة من الشاشة، يجب عليك تعطيل المساحة 
	\InlineCode{screen} :
	
\begin{Csource}
SDL_LockSurface(screen);
\end{Csource}

	\item يمكنك بعد ذلك تغيير محتوى كلّ بيكسل من المساحة. بما أن الـ\textenglish{SDL}
	لا تقترح أية دالة للقيام بهذا، يجب أن نكتبها بأنفسنا في البرنامج.
	
	سأعطيك هذه الدالة، و التي استخرجتها من الملفات التوجيهية للـ\textenglish{SDL}.
	هي معقدّة أكثر لأنها تعمل على المساحة مباشرة و تتحكم في كلّ أعماق اللون الممكنة (بيتات على البيكسل). لا تحتاج لحفظها أو فهمها، قم بنسخها ببساطة في البرنامج لكي تتمكّن من استعمالها :
	
\begin{Csource}
void setPixel(SDL_Surface *surface, int x, int y, Uint32 pixel)
{
	int bpp = surface->format->BytesPerPixel;
	
	Uint8 *p = (Uint8 *)surface->pixels + y * surface->pitch + x * bpp;
	
	switch(bpp) {
		case 1:
		*p = pixel;
		break;
		
		case 2:
		*(Uint16 *)p = pixel;
		break;
		
		case 3:
		if(SDL_BYTEORDER == SDL_BIG_ENDIAN) {
			p[0] = (pixel >> 16) & 0xff;
			p[1] = (pixel >> 8) & 0xff;
			p[2] = pixel & 0xff;
		} else {
			p[0] = pixel & 0xff;
			p[1] = (pixel >> 8) & 0xff;
			p[2] = (pixel >> 16) & 0xff;
		}
		break;
		
		case 4:
		*(Uint32 *)p = pixel;
		break;
	}
}
\end{Csource}
\end{enumerate}

هي سهلة الإستعمال. ابعث لها المعاملات التالية :

\begin{itemize}
	\item المؤشّر نحو المساحة التي تريد التعديل عليها (يجب أن تكون معطّلة بواسطة
	\InlineCode{SDL\_LockSurface}).
	\item وضعية الفاصلة الخاصة بالبيكسل الذي نريد التعديل عليه في المساحة
	(\InlineCode{x}).
	\item وضعية الترتيبة الخاصة بالبيكسل الذي نريد التعديل عليه في المساحة
	(\InlineCode{y}).
	\item اللون الجديد الذي نعطيه للبيكسل. يجب أن يكون هذا اللون بصيغة
	\InlineCode{Uint32}
	يمكنك إذا توليده بالإستعانة بالدالة
	\InlineCode{SDL\_MapRGB}
	التي تتقننها جيداً الآن.
	\item أخيراً، حينما تنتهي من العمل على المساحة، يجب ألا تنسى أن تزيل تعطيلها باستدعاء\\ 
	\InlineCode{SDL\_UnlockSurface}.
\end{itemize}

\begin{Csource}
SDL_UnlockSurface(screen);
\end{Csource}

\subsection{شفرة  ملخّصة للمثال}

لو نلخّص، ستجد بأن كلّ شيء سهل.\\
هذه الشفرة ترسم بيكسلا أحمرا في منتصف المساحة
\InlineCode{screen}
(أي في منتصف النافذة).

\begin{Csource}
SDL_LockSurface(screen); // We lock the surface
setPixel(screen, screen->w / 2, screen->h / 2, SDL_MapRGB(screen->format, 255, 0, 0)); // We draw a red pixel in the middle of the screen
SDL_UnlockSurface(screen); // We unlock the surface
\end{Csource}

من هذه القاعدة، يجدر بك أن تتمكن من تحقيق التدرّج اللوني من الأخضر للأحمر (يجب أن تستعمل الحلقات التكرارية).
