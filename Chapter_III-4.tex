\chapter{معالجة الأحداث}

معالجة الأحداث هو من أهم الأساسيات في الـ\textenglish{SDL}.\\
و ربّما قد يكون الشطر الأكثر شغفاً لاكتشافه. لأنه انطلاقا من هنا ستبدأ فعلاً في التحكّم في تطبيقك.

كلّ من مرفقات الحاسوب (فأرة، لوحة مفاتيح، \dots) قادرة على إنتاج حدث. سنتعلّم كيف نستقبل كل حدث و نتعامل معه. تطبيقك سيصبح أخيراً تفاعليّا !

فعلياً، ما هو الحدث ؟ الحدث هو عبارة عن إشارة
(\textenglish{signal})
يتم إرسالها عن طريق إحدى مرفقات الحاسوب 
(\textenglish{peripherals})
(أو عن طريق نظام التشغيل بذاته) إلى التطبيق. هذه أمثلة عن بعض الأحداث المألوفة :

\begin{itemize}
	\item حينما يضغط المُستعمل على زر من لوحة المفاتيح.
	\item و أيضاً حينما ينقر بالفأرة.
	\item حينما يحرّك الفأرة.
	\item حينما يقوم بتصغير النافذة.
	\item حينما يطلب إغلاق النافذة.
	\item إلى آخره.
\end{itemize}

الهدف من هذا الدرس هو تعلّم كيفية معالجة الأحداث. يمكنك أخيراً القول للحاسوب : "إذا نقر المستعمل في هذا المكان، قم بفعل كذا، و إن لم يفعل، قم بكذا. إذا حرّك الفأرة، قم بكذا. إذا ضغط على الزر
\InlineCode{Q}،
أوقف البرنامج. إلخ".

\section{مبدأ عمل الأحداث}

لنتعوّد على الأحداث، سنتعلّم كيف نتعامل مع أسهل حدث :
\textbf{طلب غلق البرنامج}.
هذا حدث يـُنتجُ حينما يقوم المستعمل بالنقر على الزر
\InlineCode{X} :

\Picture{Chapter_III-4_Close}

إنه فعلاً الحدث الأكثر سهولة. إضافة على ذلك، هو حدث قد استعملته سابقاً دون أن تعلم بذلك لأنه متواجد في الدالة 
\InlineCode{pause} !\\
بالفعل، دور هذه الدالة هو انتظار المستعمل حتّى يقررّ غلق البرنامج، لأننا لو لم نستعملها كانت النافذة لتظهر و تختفي بسرعة البرق !

\begin{information}
يمكنك من الآن نسيان الدالة
\InlineCode{pause}.
قم بحذفها من الشفرة المصدرية لأننا سنتعلّم كيف نكتب محتواها بأنفسنا.
\end{information}

\subsection{متغيّر الحدث}

لمعالجة الأحداث، ستحتاج إلى التصريح عن متغيّر (واحد فقط، كن متأكدا) من نوع 
\InlineCode{SDL\_Event}.\\
فلتقم بتسميته بالاسم الذي يحلو لك، أنا سأسمّيه 
\InlineCode{event}،
و هي تعني "حدث" بالإنجليزيّة.

\begin{Csource}
SDL_Event event;
\end{Csource}

من أجل اختبارات الشفرة، سنستعمل دالة
\InlineCode{main}
بسيطة للغاية تقوم بإظهار نافذة فقط، مثلما رأينا في الفصول الأولى. هذا ما يجب أن تبدو عليه الدالة
\InlineCode{main} :

\begin{Csource}
int main(int argc, char *argv[])
{
	SDL_Surface *screen = NULL;
	SDL_Event event; // This variable will help us to manage the events
	SDL_Init(SDL_INIT_VIDEO);
	screen = SDL_SetVideoMode(640, 480, 32, SDL_HWSURFACE);
	SDL_WM_SetCaption("Managing the events in SDL", NULL);
	SDL_Quit();
	return EXIT_SUCCESS;
}
\end{Csource}

إذا، هي شفرة بدائية جداً، و هي لا تحوي سوى شيء جديد : تعريف المتغير
\InlineCode{event}
الذي سنستعين به قريباً.

جرّب الشفرة : مثلما توقّعنا، يجدر بالنافذة أن تظهر و تختفي في لحظة.

\subsection{حلقة الأحداث}

حينما نريد انتظار حدث، نستعمل غالباً حلقة. هذه الحلقة التكرارية تستمر في الاشتغال مادُمنا لم نستقبل الحدث المـُراد.\\
يجب علينا أن نستعمل متغيراً منطقياً لكي يحدد لنا ما إن كان علينا البقاء في الحلقة أو الخروج منها.\\
أنشئ هذا المتغير و سمّه مثلا
\InlineCode{cont}\footnote{
إذا كنت تفكّر في تسميته
\InlineCode{continue}
فلا تفعل، لأنّها كلمة مفتاحيّة (محجوزة)، و بالتالي لا يمكن استخدامها كاسم لمتغيّر.} :

\begin{Csource}
int cont = 1;
\end{Csource}

هذا المتغير المنطقي يأخذ القيمة 1 في البداية لأننا نريد للحلقة أن تتكرر مادام المتغير
\InlineCode{cont}
يحمل هذه القيمة (صحيح). ما إن يأخذ المتغير المنطقي القيمة 0 (خطأ)، نخرج من الحلقة و يتوقف البرنامج.

هذا ما تبدو عليه الحلقة :

\begin{Csource}
while (cont)
{
	// Dealing with the event
}
\end{Csource}

هكذا إذاً : لدينا لحدّ الآن حلقة غير منتهية لا تنتهي إلا إذا أخذ المتغير 
\InlineCode{cont}
القيمة 0. الأكثر أهمية هو ما نكتبه في داخل تلك الحلقة.

\subsection{استرجاع الحدث}

الآن سنقوم باستدعاء دالة من الـ\textenglish{SDL}
لكي نتحقق ما إن تم إنتاج حدث.\\
لدينا دالتان للقيام بهذا العمل، لكن كلا منهُما تعمل بطريقة مختلفة عن الأخرى :

\begin{itemize}
	\item \InlineCode{SDL\_WaitEvent} :
	تقوم بانتظار إنتاج حدث. هذه الدالة نقول عنها تعطيلية لأنها توقف عمل البرنامج مادام لم يتم إنتاج أي حدث.
	\item \InlineCode{SDL\_PollEvent} :
	هذه الدالة تقوم بنفس العمل لكنها ليست تعطيلية. لأنها تُخبرنا ما إن تم انتاج حدث أم لا، فإن لم يكن هناك أي حدث فإنها تعيد التحكّم إلى البرنامج مباشرة.
\end{itemize}

هاتان الدالّتان مهمّتان، لكن في حالتين مختلفتين.\\
لتبسيط الأمور، إذا استعملت 
\InlineCode{SDL\_WaitEvent}
فإن برنامجك لن يـُتعب كثيراً المـُعالج لأنه سيتوقف مـُنتظراً إنتاج حدث.\\
بالمـُقابل، إذا استعملت 
\InlineCode{SDL\_PollEvent}،
سيقوم البرنامج بالعمل على الحلقة
\InlineCode{while}
و استدعاء الدالة 
\InlineCode{SDL\_PollEvent}
بشكل غير معرّف إلى حين انتاج حدث مُعين. و بهذا تستعمل المُعالج  بنسبة 100
\%.

\begin{question}
لكن ألا يجب أن نستعمل دائماً الدالة 
\InlineCode{SDL\_WaitEvent}
بما أنها لا تستعمل المـُعالج كثيراً ؟
\end{question}

كلّا، لأنه توجد حالات لا يمكن الاستغناء فيها عن الدالة 
\InlineCode{SDL\_PollEvent}.
و هي حالة الألعاب التي يتم فيها تحديث الشاشة حتى و إن لم يكن هناك أي حدث.\\
فلنأخذ مثلاً اللعبة 
\textenglish{Tetris} :
تقوم الكتل بالنزول لوحدها، لا يحتاج المُستعمل إلى إنتاج حدث من أجل حصول هذا الأمر ! لو استعملنا
\InlineCode{SDL\_WaitEvent}،
سيبقى البرنامج مـُعطّلا و لن تتمكّن من تحديث الشاشة لإنزال الكتل !

\begin{question}
ماذا تفعل
\InlineCode{SDL\_WaitEvent}
لكي لا تستهلك من الـمُعالج كثيراً ؟\\
فبعد كل شيء، الدالة مُجبرة على البقاء في حلقة غير منتهية لكي تختبر كلّ الوقت ما إن كان هناك حدث أم لا، أليس كذلك ؟
\end{question}

الحقيقة أنني كنت أطرح هذا السؤال قبل وقت قليل. الإجابة معقّدة قليلاً لأنها تخصّ الطريقة التي يتحكّم فيها النظام بالعمليّات 
(\textenglish{Processes})
(البرامج التي هي في طور الاشتغال).\\
إذا كنت تريد -لكنّي سأتحدّث بسرعة-، بالنسبة للدالة 
\InlineCode{SDL\_WaitEvent}،
عمليّة البرنامج تُوضع في طور الانتظار.\\
إذا فإن البرنامج لا يعمل عليه المعالج بعد تلك اللحظة.\\
سيتم "إيقاظه" من طرف نظام التشغيل حينما يتم إنتاج حدث. يعني أن المعالج سيعود إلى العمل على البرنامج في هذه اللحظة. هذا ما يشرح لِمَ لا يستهلك البرنامج من المعالج شيئا بينما يكون في طور انتظار الحدث.

أدري أن هذه المفاهيم تبدو مجرّدة لك الآن. لكنك لست مُجبراً على فهم كل هذا الآن لأنك ستبدأ في التأقلم مع هذه المعلومات شيئاً في شيئاً مع التطبيق.\\
الآن سنستعمل 
\InlineCode{SDL\_WaitEvent}
لأن البرنامج سيبقى بسيطا باستخدامها. على أي حال فالتعامل مع هاتين الدالتين لن يتغير من واحدة إلى أخرى.

يجب أن تبعث للدالة عنوان المتغير 
\InlineCode{event}
الذي يقوم بتخزين الحدث.\\
بما أن هذا المتغير ليس عبارة عن مؤشّر (أعد رؤية طريقة التصريح به أعلاه)، سنستعمل الاشارة
\InlineCode{\&}
قبل اسم المتغير و ذلك لنُعطي عنوانه :

\begin{Csource}
SDL_WaitEvent(&event);
\end{Csource}

بعد استدعاء هذه الدالة، المتغير
\InlineCode{event}
يحتوي إجبارياً حدثاً ما.

\begin{information}
هذه الحالة ليست نفسها لو استعملنا
\InlineCode{SDL\_PollEvent}
لأن هذه الأخيرة قادرة على أن تُرجع لنا : "لا يوجد أي حدث".
\end{information}

\subsection{تحليل الحدث}

الآن نحن نتوفر على متغير
\InlineCode{event}
يحتوي على معلومات حول الحدث الذي تم إنتاجه.\\
يجب أن نرى المركّب
\InlineCode{event.type}
و نختبر قيمته. غالبا ما نستعمل
\InlineCode{switch}
لاختبار الحدث.

\begin{question}
لكن كيف لنا أن نعرف ما هي القيمة الموافقة للحدث "أغلق البرنامج" مثلا ؟
\end{question}

الـ\textenglish{SDL}
توفّر لنا بعض الثوابت، مما يسهّل كثيراً كتابة البرنامج. هذه الثوابت كثيرة العدد (بقدر وجود أحداث ممكن حصولها في الحاسوب). سنتعرّف على هذه الثوابت بتقدّمنا في هذا الفصل.

\begin{Csource}
while (cont)
{
	SDL_WaitEvent(&event); // Getting the event in "event"
	switch(event.type) // Testing the event's type
	{
		case SDL_QUIT: // If it's a quit event
		cont = 0;
		break;
	}
}
\end{Csource}

هكذا تعمل الشفرة :

\begin{enumerate}
	\item ما إن يتم انتاج حدث، تُرجع الدالة 
	\InlineCode{SDL\_WaitEvent}
	الحدث في المتغير 
	\InlineCode{event}.
	\item نقوم بتحليل نوع الحدث بالاستعانة بـ\InlineCode{switch}.
	نوع الحدث موجود في
	\InlineCode{event.type}.
	\item نختبر بمساعدة 
	\InlineCode{case}
	نوع الحدث. لحدّ الآن، نحن لا نتحقق إلا إذا ما كان الحدث يوافق
	\InlineCode{SDL\_QUIT}
	(طلب إغلاق البرنامج)، لأنّها الحالة الوحيدة التي تهمّنا.
	\item إذا كان الحدث هو 
	\InlineCode{SDL\_QUIT}،
	فهذا يعني أن المستعمل طلب إغلاق البرنامج. في هذه الحالة، نعطي للمتغير المنطقي
	\InlineCode{cont}
	القيمة 0. في الدورة القادمة للحلقة، سيكون الشرط غير محقق، فيتوقف تشغيل البرنامج.
	\item إذا لم يكن الحدث هو 
	\InlineCode{SDL\_QUIT}،
	مما يعني أنه قد حدث شيء آخر : قام المستعمل بالضغط على زر، بالنقر على الفأرة أو ببساطة قام بتحريك الفأرة داخل النافذة. و بما أن هذه الأحداث لا تهمّنا، لن نقوم بمعالجتها. لن نقوم إذا بأي شيء : تقوم الحلقة بالانتقال في كلّ مرة إلى دورة جديدة ننتظر فيها حدوث حدث جديد (بمعنى آخر، نعود إلى النقطة 1).
\end{enumerate}

ما أنا أشرحه لك الآن هو أمر مهم جداً. إذا فهمت هذه الشفرة، فقد فهمت كلّ شيء و سيكون باقي الدرس سهلاً للغاية.

\subsection{الشفرة الكاملة}

\begin{Csource}
int main(int argc, char *argv[])
{
	SDL_Surface *screen = NULL;
	SDL_Event event; // The event's variable
	int cont = 1; // A boolean for the loop
	SDL_Init(SDL_INIT_VIDEO);
	screen = SDL_SetVideoMode(640, 480, 32, SDL_HWSURFACE);
	SDL_WM_SetCaption("Managing the events in SDL", NULL);
	while (cont) // While the variable's value is 
	{            // not equal to 0
		SDL_WaitEvent(&event); // We wait for an event that we recuperate in "event"
		switch(event.type) // Testing the event's type
		{
			case SDL_QUIT: // If it's a quit event
			cont = 0; // We change the boolean value so we go out from the loop.
			break;
		}
	}
	SDL_Quit();
	return EXIT_SUCCESS;
}
\end{Csource}

هاهي الشفرة الكاملة. لا يوجد شيء صعب : إذا قمت بمتابعة الدرس إلى الآن، يجدر بك أن تكون قد فهمت كلّ شيء. على أي حال فقد لاحظت أنّنا لم نقم إلا بإعادة كتابة ما تقوم به الدالة 
\InlineCode{pause}.
قارن هذه الشفرة بما تقوم به الدالة
\InlineCode{pause} :
هو نفس الشيء، إلا أنه في هذه الحالة نقوم بوضع كلّ شيء في الدالة
\InlineCode{main}.
بالطبع، من المستحسن نقل الشفرة إلى دالة أخرى على حدى كـ\InlineCode{pause}،
لأن ذلك سيقلّل من حجم الدالة
\InlineCode{main}
و يجعلها أفضل من ناحية فهم الشفرة.
