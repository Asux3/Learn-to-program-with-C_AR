\chapter{القوائم المتسلسلة (\textenglish{Linked lists})}

لكي نخزّن المعلومات في الذاكرة، استعملنا متغيّرات بسيطة (من نوع
\InlineCode{int}، \InlineCode{double} \dots)،
كما استعملنا جداول و هياكل مخصّصة. إذا أردت تخزين سلسلة من البيانات، فالأبسط غالباً هو استعمال جداول. 

لكن تصبح الجداول أحياناً محدودة جداً. مثلاً، إذا أنشأت جدولاً ذو 10 خانات ثم تبيّن لك لاحقاً في البرنامج أنك تحتاج إلى حجم أكبر، سيكون من المستحيل تكبير حجم الجدول. و أيضاً لا يمكنك إدخال خانة إلى وسط الجدول.

تمثّل القوائم المتسلسلة طريقة لتنظيم البيانات في الذاكرة بطريقة أكثر مرونة. و بما أن لغة الـ\textenglish{C}
لا تقترح قاعدياً هذا النظام من التخزين، سيكون علينا أن ننشئه بأنفسنا. سيكون تمريناً ممتازاً يساعدك على أن ترتاح أكثر مع هذه اللغة.

\section{تمثيل قائمة متسلسلة}

ماهي القائمة المتسلسلة ؟ أقترح عليك أن تنطلق من نموذج الجدول. يمكن تمثيل الجدول في الذاكرة بالطريقة التي توضّحها الصورة التالية. نتكلّم هنا عن جدول يحتوي على خانات من نوع
\InlineCode{int}.

\Picture{Chapter_IV-1_Array}

\begin{information}
اخترت هنا تمثيل الجدول أفقياً، لكن يمكن تمثيله عمودياً كذلك، هذا لا يهم.
\end{information}


كما قلت لك في المقدّمة، مشكل الجداول يمكن في كونها ثابتة. لا يمكن تكبير حجمها، إلا إذا فكّرنا في إعادة إنشائها من جديد و تكون أكبر (لاحظ الشكل التالي). أيضاً، لا يمكن أن نضيف عنصُراً في وسط الجدول إلا إذا قمنا بإزاحة كلّ العناصر الأخرى.

\Picture{Chapter_IV-1_Array-add}

لا تقترح علينا لغة الـ\textenglish{C}
نظاماً آخراً لتخزين البيانات، لكن من الممكن أن ننشئ بأنفسنا هذا النظام بعناصره الكاملة : ستكون الغاية من هذا الفصل و الفصول الموالية اكتشاف حلول لهذا المشكل.

القائمة المتسلسلة هي طريقة لتنظيم سلسلة من البيانات في الذاكرة. هذا يسمح بجمع هياكل
(\textenglish{structures})
مرتبطة ببعضها البعض بواسطة مؤشّرات. يمكننا تمثيلها كالتالي :

\Picture{Chapter_IV-1_Linked-list}

يمكن لكلّ عنصر أن يحتوي على ما نريد : قيمة من نوع 
\InlineCode{int}
أو أكثر،
\InlineCode{double} \dots
بالإضافة إلى ذلك، كلّ عنصر يحتوي على مؤشّر نحو العنصر الموالي :

\Picture{Chapter_IV-1_Linked-list-data}

أعرف بأن كلّ هذه المعلومات نظرية و ربّما تبدو لك غير واضحة الآن. احفظ فقط طريقة اتّصال العناصر ببعضها : هي تشكل 
\textbf{سلسلة من المؤشّرات}،
و من هنا نجد الإسم "قائمة متسلسلة". 

\begin{information}
على عكس الجداول، لا تتموضع عناصر السلسلة المتّصلة جنباً إلى جنب في الذاكرة. كل خانة تؤشّر نحو خانة أخرى لا تتواجد ضرورياً بجنب الأخرى.
\end{information}

\section{بناء قائمة متسلسلة}

فلنمرّ الآن إلى صلب الموضوع. سنحاول أن ننشئ بُنية تعمل بنفس المبدأ الذي اكتشفناه الآن.\\
أذكّرك بأن كلّ ما سنقوم به هنا يستدعي تقنيات لغة الـ\textenglish{C}
 التي تعرفها من قبل. لا يوجد شيء جديد، سنكتفي بإنشاء هياكلنا الخاصة و دوال ثم تحويلها إلى نظام منطقي قادر على العمل لوحده.

\subsection{عنصر من القائمة}

من أجل الأمثلة، سننشئ قائمة متسلسلة من أعداد صحيحة. كل عنصر من القائمة له شكل الهيكل التالي :

\begin{Csource}
typedef struct Element Element;
struct Element
{
	int number;
	Element *next;
};
\end{Csource}

\begin{information}
يمكننا أيضاً إنشاء قوائم متسلسلة تحتوي أعدادا عشرية أو حتى جداول أو هياكل. مبدأ القوائم المتسلسلة صالح من أجل أي نوع من البيانات مهما كان، لكن هنا، أنصحك بتبسيط العملية حتى تفهم المبدأ.
\end{information}

قًمنا الآن بإنشاء عنصر واحد من القائمة، يوافق الصورة التي رأيناها أعلاه. على ماذا يحتوي الهيكل ؟

\begin{itemize}
	\item قطعة بيانات، هنا تتمثل في عدد من نوع 
	\InlineCode{int} :
	يمكننا تغيير هذا بأي قطعة أخرى
	(\InlineCode{double}،
	جدول \dots). هذا يعتمد على نوع البيانات التي تريد تخزينها، سيكون عليك تغييرها على حسب حاجتك في البرنامج.
	
	\begin{information}
		إذا أردنا العمل بطريقة عامة، الأمثل هو استعمال مؤشّر نحو الفراغ :
		\InlineCode{void*}.
		هذا يسمح بالتأشير على أي نوع من البيانات.
	\end{information}
	\item مؤشّر نحو عنصر من نفس النوع يسمّى
	\InlineCode{next}.
	هذا ما يسمح بوصل العناصر الواحد بالآخر : كلّ عنصر "يعلم" أين يتواجد العنصر الذي يليه في الذاكرة. كما قلتُ لك مسبقاً، الخانات لا تتواجد جنباً إلى جنب في الذاكرة. هذا هو الإختلاف الكبير بالنسبة للجداول. هذا ما سيمنحنا مرونة أكثر لأنه بإمكاننا بسهولة إضافة خانات أخرى لاحقاً حينما نحتاج إليها.

\begin{information}
	و بالمقابل، لا يمكننا معرفة العنصر السابق، أي أنه من المستحيل الرجوع إلى الخلف انطلاقاً من عنصر من هذا النوع من القوائم. لأننا هنا نتكلّم عن قائمة "بسيطة التسلسل"، بينما توجد قوائم أخرى تسمّى "مزدوجة التسلسل" و تحتوي على مؤشّرات في كلتا الجهتين و بهذا فهي أصعب بقليل.
\end{information}
\end{itemize}


\subsection{هيكل التحكّم}

بالإضافة إلى الهيكل الذي نحن بصدد بنائه (و الذي نضاعفه بعدد المرات التي فيها عناصر أخرى)، سنحتاج إلى هيكل آخر لكي نتحكّم في كامل القائمة المتسلسلة. سيكون لهذا الهيكل الشكل التالي :

\begin{Csource}
typedef struct List List;
struct List
{
	Element *first;
};
\end{Csource}

هذا الهيكل
\InlineCode{List}
يحتوي على مؤشّر نحو أوّل عنصر من القائمة. في الواقع، يجب الاحتفاظ بعنوان العنصر الأول لكي نعرف أين تبدأ القائمة. إذا عرفنا العنصر الأول، يمكننا أن نجد العناصر الأخرى بـ"القفز" من عنصر لآخر بالإستعانة بالمؤشرات الموالية.

\begin{information}
هيكل مكوّن من مركّب واحد هو في الغالب غير مفيد. و مع ذلك، أعتقد أننا سنحتاج أن نضيف إليه لاحقاً مركّبات أخرى، يمكننا مثلاً أن نخزّن به حجم القائمة، أي عدد العناصر التي تحتويها.
\end{information}

لن يكون علينا إنشاء سوى نسخة واحدة من الهيكل
\InlineCode{List}.
هي تسمح بالتحكّم في كلّ السلسلة :
 
\Picture{Chapter_IV-1_List-struct}

\subsection{آخر عنصر في القائمة}

المخطط أصبح تقريباً كاملاً. ينقصه شيء أخير : نفضّل أن نحفظ العنصر الأخير من القائمة. في الواقع، يجب أن نتوقّف من التقدّم في السلسلة في لحظة ما. كيف سيتسنى لنا أن نقول للبرنامج : "توقف، هذا هو آخر عنصر" ؟

سيكون ممكناً أن نضيف إلى الهيكل 
\InlineCode{List}
مؤشّرا نحو آخر عنصر. لكن هناك ما هو أبسط : يكفي أن يؤشّر آخر عنصر من القائمة على
\InlineCode{NULL}،
أي إعطاء المؤشّر
\InlineCode{next}
القيمة
\InlineCode{NULL}.
هذا سيسمح لنا أخيراً برسم مخطط كامل لبُنية القائمة المتسلسلة :

\Picture{Chapter_IV-1_List-NULL}
