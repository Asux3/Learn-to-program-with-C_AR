\chapter{إدخال نصّ بشكل أكثر أمانا}

إدخال النصوص في لغة الـ\textenglish{C}
هي من أكثر الأمور حساسية. أنت تعرف الدالة
\InlineCode{scanf}
التي تعرّفنا عليها في الدروس الأولى. ستقول : و أيّ الأدوات ستكون أكثر سهولة و طبيعية منها ؟ لكن جهّز نفسك، بعد هذا الدرس ستقول عنها أي شيء باستثناء "بسيطة".

الذين سيستعملون برنامجك هم بطبيعة الحال بشر. فهناك منهم من يخطئ في كتابة شيء، بينما هناك من يتعمّدون إرباك برنامجك بمعلومات غير منتظرة. فإن طلبت من المستعمل : ما هو عُمرك ؟ من يضمن لك بأنه لن يجيبك بـ:" إسمي فلان و أنا من البلد فلان" ؟

الهدف من هذا الدرس هو تعريفك إلى بعض المشاكل التي يمكن أن نواجهها أثناء استعمالنا للدالة
\InlineCode{scanf}،
و تقديم دالة بديلة أكثر أماناً و هي
\InlineCode{fgets}.

\section{حدود الدالة \texttt{scanf}}

هذه الدالة التي نستعملها جميعاً من الدروس الأولى في الكتاب، هي سلاح ذو حدين :

\begin{itemize}
  \item سهلة الاستعمال حينما نكون في مستوى "مبتدئ" ، و لهذا السبب عرّفتك بها.
  \item لكن الطريقة التي تعمل بها معقّدة و يمكن أن تكون خطيرة في بعض الحالات.
\end{itemize}

ألا يبدو الأمر متناقضا ؟ فإن الدالة
\InlineCode{scanf}
سهلة الاستعمال و في نفس الوقت أكثر تعقيداً مما نتصور، سأريك الحدود التي يمكن لهذه الدالة أن تصل إليها و ذلك بتقديم مثالين واقعيين.

\subsection{إدخال سلسلة محارف تحتوي على فراغات }

لنفرض أننا طلبنا من المستعمل أن يقوم بإدخال سلسلة محارف في الكونسول، و هو يقوم بكتابة فراغ في سلسلته~:

\begin{Csource}
  #include <stdio.h>
  #include <stdlib.h>
  int main(int argc, char *argv[])
  {
  	char name[20] = {0};
  	printf("What's your name ? ");
  	scanf("%s", name);
  	printf("Ah ! Your name is %s !\n\n", name);
  	return 0;
  }
\end{Csource}

\begin{Console}
  What's your name ? Mathieu Nebra
  Ah ! Your name is Mathieu !
\end{Console}

\begin{question}
لماذا اختفت الكلمة
"\textenglish{Nebra}"
؟
\end{question}

ذلك لأن الدالة
\InlineCode{scanf}
تتوقف عن القراءة حينما تصل إلى فراغ، أو رجوع إلى السطر أو محرف جدولة
(\textenglish{tabulation}).
يعني أنك غير قادر على قراءة سلسلة محرفيّة تحتوي على فراغات.

\begin{information}
  في الواقع، الكلمة
  "\textenglish{Nebra}"
  لازالت مخزّنة في الذاكرة، في  شيء نسميه بالمتغير المؤقّت
  (\textenglish{buffer})،
  المرة القادمة عندما نستدعي الدالة
  \InlineCode{scanf}
  فهي ستقوم بقراءة الكلمة
  "\textenglish{Nebra}"
    وحدها الموجودة في المتغير المؤقت.
\end{information}

يمكننا استعمال الدالة
\InlineCode{scanf}
بشكل يسمح لها بقراءة الفراغات، لكن الأمر معقّد جدّا. لمن يصرّ على ذلك، يمكنك إيجاد دروس مفصّلة على الويب، مثل الدرس الأجنبي المتوفّر على هذا الرابط :

\url{http://xrenault.developpez.com/tutoriels/c/scanf/}

\subsection{إدخال سلسلة محارف طويلة للغاية}

يوجد مشكل آخر، أكثر خطورة، و هو
\textbf{تجاوز الذاكرة}.

في الشفرة التي رأيناها، يوجد السطر التالي :

\begin{Csource}
  char name[5] = {0};
\end{Csource}

ترى أنني قمت بحجز 5 خانات من أجل الجدول المسمّى
\InlineCode{name}
الذي هو من نوع
\InlineCode{char}.
يعني أننا قادرون على تخزين كلمة من 4 محارف، بينما الحرف الأخير فهو محجوز لعلامة نهاية السلسلة
\InlineCode{\textbackslash 0}.\\
إذا نسيت كلّ هذا فراجع درس السلاسل المحرفية.

المخطط التالي يمثل المكان الذي هو محجوز للكلمة التي عرّفناها :

\Picture{Chapter_II-10_array}

ماذا لو كتبنا عددا كبيرا من المحارف بالنسبة للمساحة المتوقّعة لتخزين المتغير ؟

\begin{Console}
What's your name ? Patrice
Ah ! Your name is Patrice !
\end{Console}

ستقول أن كل شيء على ما يرام لكن الواقع أنك بصدد مواجهة أكبر كابوس لدى المبرمجين !

لقد قمنا بـ\emph{تجاوز في الذاكرة}،
 هذا ما نسميه بـ\emph{\textenglish{buffer overflow}}
بالإنجليزية.

كما ترى في المخطط التالي، لقد حجزت 5 خانات لكي تقوم باستعمال 8، ما الذي قامت به الدالة
\InlineCode{scanf}~؟
 لقد قامت بمواصلة الكتابة في الذاكرة وكأن شيئاً لم يحدث ! فلقد استغلّت خانات ليس لها الحق في الكتابة فيها.

\Picture{Chapter_II-10_array_patrice}

الذي جرى في الحقيقة، هو أن المحارف الزائدة تسببت في مسح معلومات من الذاكرة و استبدالها بهذه المحارف. هذا ما نسميه بالـ\emph{\textenglish{buffer overflow}}.

\Picture{Chapter_II-10_array_overflow}

\begin{question}
  لم الأمر خطير ؟
\end{question}

دون الدخول في التفاصيل، لأنه بإمكاننا البدء في محادثة  قدر 50 صفحة و لا نتوقف أبداً، فلنقل بأنه إن لم يقم البرنامج بالتحكم في حالات كهذه، فالمستعمل سيقوم بكتابة ما يحلو له و تخريب المعلومات المتواجدة في الخانات التالية من الذاكرة. أي أنه قادر على كتابة شفرة في تلك الخانات و برنامجك سيقوم بتشغيل تلك الشفرات و كأنها تابعة له، و هذا ما نسميه بالهجوم عبر المتغير المؤقت
\textenglish{buffer overflow attack}،
نوع من الهجومات المعروفة عند القراصنة، و لكنه صعب التحقيق.\\
إذا كنت مهتماً بهذا الموضوع، يمكنك قراءة المقال التالي من ويكيبيديا ( حذار، إنّه مع ذلك معقد جدا ) :

\url{http://fr.wikipedia.org/wiki/D%C3%A9passement_de_tampon}

الهدف من هذا الفصل هو تأمين قراءة البيانات و ذلك بمنع المستعمل من تجاوز الذاكرة و إحداث
\textenglish{buffer overflow}.
بالطبع كان بإمكاننا تعريف جدول كبير للغاية ( 10.000 خانة ) لكن هذا لا يحلّ المشكل فالشخص الذي يريد الوصول إلى الذاكرة ما عليه سوى إدخال سلسلة يتجاوز طولها 10.000 محرف و سيعمل هجومه كما يريد.

الشيء المحزن هو أن معظم المبرمجين لا ينتبهون دائما لهذه الأخطاء، و لو أنهم قاموا بكتابة الشفرة من المرة الأولى بشكل نظيف و صحيح، لما ظهرت كثير من الثغرات من التي نتحدّث عنها اليوم.
