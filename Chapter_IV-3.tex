\chapter{جداول التجزئة (\textenglish{Hash tables})}

للقوائم المتسلسلة نقطة ضعف كبيرة في حال أردنا قراءة محتواها : يستحيل الوصول إلى عنصر معيّن مباشرة. يجب التقدّم في القائمة عنصراً بعنصر حتى نجد العنصر الذي نريد. هذا يطرح مشاكل من ناحية الأداء ما إن يكون حجم القائمة المتسلسلة ضخماً. تخيّل قائمة متسلسلة تتكوّن من 1000 عنصر بينما العنصر الذي نبحث عنه موجود في آخرها !

تمثّل جداول التجزئة طريقة أخرى لتخزين البيانات. حيث أنها تستند على مبدأ الجداول في لغة الـ\textenglish{C}
و التي نعرف التعامل معها جيّداً. ماهي فائدتها الكُبرى ؟ هي تسمح بإيجاد سريع لعنصر محدد، سواء كان الجدول يحتوي 100، 1000، 10000 خانة أو حتى أكثر !

\section{لماذا نستعمل جدول تجزئة ؟}

لننطلق من المشكل الذي تطرحه القوائم المتسلسلة. هذه الأخيرة مرنة بشكل خاص، هذا ما استطعنا ملاحظته : يمكننا إضافة أو إزالة خانات في أي لحظة نريد، بينما يكون الجدول "ثابتاً" ما إن يتم إنشاؤه.

لكن، كما قلتُ لك في المقدّمة، للقوائم المتسلسلة عيب كبير : إذا أردنا استرجاع عنصر محدد من القائمة، يجب تصفّح هذه الأخيرة حتى نجد ذلك العنصر !

تخيّل قائمة متسلسلة تحتوي معلومات حول التلاميذ : الإسم، العُمر و المعدّل. سيتم تمثيل كلّ تلميذ بهيكل نسميه
\InlineCode{Student}.

\begin{information}
عملنا سابقاً على القوائم المتسلسلة التي تحتوي على
\InlineCode{int}.
 كما قلتُ لك، من الممكن تخزين أي شيء نريد في قائمة، حتى مؤشّراً نحو هيكل آخر كما سأقترحه لك الآن.
\end{information}

 إذا أردتُ الوصول إلى المعلومات الخاصة بالشخص
\textenglish{Luc Doncieux}
 في الصورة الموالية، يجب عليّ التقدّم في كلّ القائمة كي أكتشف بأنه العنصر الأخير فيها !
 
\Picture{Chapter_IV-3_Student-list}

\begin{information}
بالفعل، لو أننا بحثنا عن الشخص 
\textenglish{Julien Lefebvre}،
كان البحث ليكون أسرع بما أنه متواجد في بداية القائمة. و مع ذلك، لتقييم كفاءة الخوارزمية، يجب أن نفكّر دائماً في أسوء الحالات. و الأسوء هو
\textenglish{Luc}
هنا.\\
هنا، نقول أن خوارزمية البحث لها تعقيد
\textit{\textenglish{O(n)}}،
لأنه يجب تصفّح كل القائمة المتسلسلة للوصول إلى العُنصر المراد، و في أسوء الحالات يكون هذا هو آخر عنصر. إذا كانت القائمة تحتوي على 9 عناصر، يجب أن يتم تشغيل 9 دورات للحلقة كحد أقصى لإيجاد العنصر.
\end{information}

في هذا المثال، لا تحتوي القائمة المتسلسلة سوى على أربعة عناصر. سيجد الحاسوب الشخص 
\textenglish{Luc Doncieux}
بسرعة كبيرة لا تسمح لنا حتى بأن نقول كلمة "أووه". لكن تخيّل أن هذا الشخص يتواجد في آخر قائمة متسلسلة من 10000 عنصر ! ليس مقبولا أن يتم البحث في 10000 عنصر لإيجاد المعلومة. هنا تتدخّل جداول التجزئة.

\section{ماهي جداول التجزئة ؟}

إذا كنت تتذكر جيداً، لا تعرف الجداول هذا النوع من المشاكل. لهذا، كي نصل إلى العنصر في الوضعية 2 من الجدول تكفيني كتابة التالي :

\begin{Csource}
int table[4] = {12, 7, 14, 33};
printf("%d", table[2]);
\end{Csource}

لو نعطي للحاسوب
\InlineCode{table[2]}،
فسيتوجّه مباشرة إلى المكان في الذاكرة أين هو مخزّن العدد 14. أي أنه لن يتقدّم في الجدول خانة بخانة.

\begin{question}
هل أنت بصدد القول أن الجداول ليست "بذلك القدر من السوء" ؟ لكن في هذه الحالة سنخسر الميزات التي توفّرها القوائم المتسلسلة التي تسمح لنا بإضافة و إزالة خانات في أي لحظة !
\end{question}

في الواقع، القوائم المتسلسلة مرنة أكثر. أما بالنسبة للجداول، فهي تسمح بالوصول السريع للمعطيات. يمكننا القول أن 
\textbf{جداول التجزئة}
تشكّل حلّا وسطا بين الإثنين.

يوجد عيب في استعمال الجداول لم نتكلّم عنه سابقاً : يتم تعريف خانات الجدول عن طريق أرقام نسمّيها 
\textbf{الرّتب}
أو
\textbf{الدلالات}
(\textenglish{indices}).
لا يمكن أن نطلب من الحاسوب : "ماهي المعلومات المتواجدة في الخانة التي تسمّى
"\textenglish{Luc Doncieux}".
أي أننا لإيجاد العُمر و المعدّل لن نتمكّن من كتابة :

\begin{Csource}
table["Luc Doncieux"];
\end{Csource}

مع أنه سيكون عملياً لو أننا نستطيع الوصول إلى خانة ما باستعمال الاسم فقط ! حسناً، هذا ممكن باستعمال جداول التجزئة.

\begin{information}
كما رأينا مؤخّراً. لا تشكّل جداول التجزئة "جزءً" من لغة الـ\textenglish{C}.
نتحدّث هنا عن مبدأ. سنعيد استعمال أساسيات لغة الـ\textenglish{C}
التي نعرفها من قبل لأجل إنشاء نظام ذكي جديد. و كأنه في لغة الـ\textenglish{C}،
باستعمال بعض الأدوات القاعدية، يمكننا إنشاء الكثير من الأشياء !
\end{information}

\begin{question}
بما أنه من الواجب أن يتم ترقيم الجدول بالرُّتب، كيف سنجد رقم الخانة لو أننا نعرف الاسم
"\textenglish{Luc Doncieux}"
 فقط ؟
\end{question}

ملاحظة جيدة. في الواقع، يبقى الجدول جدولاً و لن يعمل إلا بالرّتب المرقّمة. تخيّل جدولاً يوافق الصورة الموالية : كل خانة لها رتبة و تتوفر على مؤشّر نحو هيكل من نوع
\InlineCode{Student}.
أنت تعرف القيام بهذا الآن :

\Picture{Chapter_IV-3_Array-indices}

 لو أردنا إيجاد الخانة التي توافق
\textenglish{Luc Doncieux}،
 يجب أن نجيد تحويل الإسم إلى رُتبة في الجدول. و بهذا، يجب أن نتمكّن من ربط كلّ اسم برقم من خانة في الجدول :

\begin{itemize}
	\item \textenglish{Julien Lefebvre} = $0$.
	\item \textenglish{Aurélie Bassoli} = $1$.
	\item \textenglish{Yann Martinez} = $2$.
	\item \textenglish{Luc Doncieux} = $3$.
\end{itemize}

لا يمكننا أن نكتب
\InlineCode{table["Luc Doncieux"]}
كما فعلتُ سابقاً. لأن هذا غير مسموح به في لغة الـ\textenglish{C}.

السؤال الذي يُطرح هو : كيف نحوّل سلسلة محارف إلى عدد ؟ هذا هو سحر التجزئة. تجب كتابة دالة تأخذ كمعامل سلسلة محارف، تطبّق حسابات عليها، ثم تُرجع لنا عدداً يوافق تلك السلسلة. سيكون هذا العدد هو رتبة الخانة في الجدول :

\Picture{Chapter_IV-3_Array-indices-hash}
