\chapter{برمجة لعبة
الـ\textenglish{Pendu}}
أكرر دائما : التطبيق شيء ضروريّ. هو ضروريّ لك لأنك اكتشفت كثيرا من المفاهيم النظرية و، أيّا كان ما تقول، لن تفهمها حقّا بدون تطبيق.

في هذا العمل التطبيقي، أقترح عليك إنشاء لعبة الـ\textenglish{Pendu}.
و هي لعبة حروف تقليديّة يتمّ فيها تخمين كلمة سريّة حرفا بحرف. و الـ\textenglish{Pendu}
سيكون إذن لعبة في الكونسول بلغة
\textenglish{C}.

الهدف هو جعلك تستخدم كلّ ما تعلّمته حتّى الآن : المؤشرات، السلاسل المحرفيّة، الملفات، الجداول... باختصار، الأشياء الجيّدة فقط !

\section{التعليمات}
سأقوم بشرح قواعد الـ\textenglish{Pendu}
الواجب إنشاءه. سأعطيك هنا التعليمات، أي سأشرح لك بدقّة كيف يجب أن تعمل اللعبة التي ستُنشئها.

أعتقد أن الجميع يعرف
الـ\textenglish{Pendu}،
أليس كذلك ؟ هيّا، تذكير صغير لا يمكن أن يحدث ضررا : هدف الـ\textenglish{Pendu}
هو إيجاد الكلمة المخبّأة في أقلّ من عشر محاولات (يمكنك تغيير العدد الأقصى لتغيير صعوبة اللعبة، بالطبع !).

\subsection{سريان الجولة}
فلنفترض أن الكلمة المخبّأة هي \textenglish{RED}.\\
ستقوم باقتراح حرف على الحاسوب، مثلا الحرف
\textenglish{A}.
سيتأكّد الحاسوب ما إن كان هذا الحرف موجوداً في الكلمة المخفيّة.

\begin{information}
تذكّر : هناك دالة جاهزة في
\InlineCode{string.h}
تقوم بالبحث عن حرف في كلمة ! و بالطبع أنت لست مجبراً على استخدامها (شخصيّا، أنا لم أفعل).
\end{information}

إنطلاقاً من هنا، يوجد احتمالان :
\begin{itemize}
  \item الحرف موجود بالفعل في الكلمة : سنكشف مكان الحرف في الكلمة.
  \item الحرف غير موجود في الكلمة (هذا هو الحال هنا، لأن
\textenglish{A}
ليس موجوداً في الكلمة
\textenglish{RED}) :
سنخبر اللاعب بأن الحرف هذا غير موجود في الكلمة، و سننقص عدد المحاولات المتبقّية. عندما لا تتبق أية محاولة (0 محاولة)، ستنتهي اللعبة و سنخسر.
\end{itemize}

\begin{information}
في لعبة
\textenglish{Pendu}
"حقيقة"، يفترض وجود شخص يتأسّف في كلّ مرّه نخطئ فيها. في الكونسول، سيكون من الصعب كثيرا رسم شخص يتأسّف بواسطة لاشيء غير النص،  لذا سنكتفي بعرض جملة بسيطة مثل "بقي لك
\textenglish{X}
محاولات قبل الموت الأكيد".
\end{information}

فلنفرض الآن أن اللاعب أدخل الحرف
\textenglish{D}.
هذا الحرف موجود في الكلمة المخفيّة، لهذا لن نقوم بإنقاص عدد المحاولات المتبقّية للاعب. سنقوم بإظهار الكلمة مع الحروف الّتي تم إيجادها، أي شيء كهذا :

\begin{Console}
Secret word : **D
\end{Console}

إذا أدخل اللاعب فيما بعد الحرف
\textenglish{R}،
و بما أنّه موجود في الكلمة، سنضيف الحرف إلى قائمة الحروف التي تم إيجادها و يتم إظهار الكلمة مع الحروف الّتي تمّ اكتشافها :

\begin{Console}
Secret word : R*D
\end{Console}

\subsubsection{حالة وجود حرف مكرر}
في بعض الكلمات، يمكن أن نجد حرفاً مكرراً مرتين أو ثلاث، أو ربّما أكثر !\\
مثلا : يوجد إثنان من
\textenglish{Z}
في كلمة
\textenglish{PUZZLE}،
و كذلك يوجد ثلاثة
\textenglish{E}
في كلمة
\textenglish{ELEMENT}.

ماذا علينا أن نفعل في حالة كهذه ؟ قواعد
\textenglish{Pendu}
واضحة : إذا أدخل اللاعب الحرف
\textenglish{E}،
كلّ حروف
\textenglish{E}
في كلمة
\textenglish{ELEMENT}
يجب أن تظهر دفعة واحدة :

\begin{Console}
Secret word : E*E*E**
\end{Console}

يعني أنه ليس على اللاعب أن يدخل 3 مرات الحرف
\textenglish{E}
ليتم إكتشاف كل تكرار له في الكلمة.

\subsubsection{مثال عن جولة كاملة}
هذا ما ستبدو عليه جولة كاملة في الكونسول عند انتهاء البرنامج :

\begin{Console}
Welcome !
You have 10 remaining tries
What's the secret word ? ****
Suggest a letter : B
You have 9 remaining tries
What's the secret word ? ****
Suggest a letter : F
You have 9 remaining tries
What's the secret word ? F***
Suggest a letter : D
You have 9 remaining tries
What's the secret word ? F**D
Suggest a letter : O
You win ! The secret word is  : FOOD
\end{Console}

\subsubsection{قراءة حرف من الكونسول}
قراءة حرف من الكونسول هي أكثر تعقيداً ممّا تبدو.\\
بديهيّا، لاسترجاع محرف، يفترض أنّك تفكّر في :

\begin{Csource}
scanf("%c", &myLetter);
\end{Csource}

و تماما، هذا جيّد.
\InlineCode{\%c}
تعني أننا ننتظر محرفاً، و الذي سنقوم بتخزينه في
\InlineCode{myLetter}
(متغيّر من نوع
\InlineCode{char}).


كل شيء يعمل جيداً... ما دمنا لم نقم بـ\InlineCode{scanf}
مرّة اخرى. يمكنك تجريب الشفرة التالية :

\begin{Csource}
int main(int argc, char* argv[])
{
 	char myLetter = 0;
 	scanf("%c", &myLetter);
 	printf("%c", myLetter);
 	scanf("%c", &myLetter);
 	printf("%c", myLetter);
 	return 0;
}
\end{Csource}

يفترض بهذه الشفرة أن تطلب حرفاً و تظهره، و ذلك لمرّتين.\\
جرّب. ما الذي يحصل ؟ تدخل حرفا، نعم، و لكن... البرنامج يتوقّف مباشرة بعدها، فهو لا يطلب منك المحرف الثاني ! و كأنه تم تجاهل
\InlineCode{scanf}
الثانية.

\begin{question}
ما الذي حصل ؟
\end{question}

في الواقع، حينما تدخل نصاً في الكونسول، فإن كل ما قمت بإدخاله يتمّ تخزينه في الذاكرة، بما في ذلك الزر
\texttt{Enter}
(\InlineCode{\textbackslash n}).

لذلك، في أوّل مرّة تدخل فيها حرفا
(\textenglish{A}
مثلاً) ثمّ تضغط على
\textit{\textenglish{Enter}}
فإن الحرف
\textenglish{A}
هو من يتم إعادته من طرف
\InlineCode{scanf}.
بينما في المرّة الثانية،
\InlineCode{scanf}
سيعيد
\InlineCode{\textbackslash n}
الموافق لـ\textit{\textenglish{Enter}}
الّذي أدخلته سابقا !

لتجنب هذا، من الأحسن أن نكتب بأنفسنا دالتنا الخاصّة الصغيرة
\InlineCode{readCharacter()} :

\begin{Csource}
char readCharacter()
{
  char character = 0;
  character = getchar(); // Read the first character
  character = toupper(character); // Convert the character to uppercase
  // Read other characters until reaching \n (to erase them)
  while (getchar() != '\n') ;
  return character; // Return the first character that have been read
}
\end{Csource}

هذه الدالة تستخدم
\InlineCode{getchar()}
الّتي هي دالة من
\InlineCode{stdio}
و هذا يعود تماماً إلى كتابة\\
\InlineCode{scanf("\%c", \&letter);}.
الدالة
\InlineCode{getchar()}
تقوم بإرجاع المحرف الذي قام اللاعب بإدخاله.

بعد ذلك، أستعمل أيضاً الدالة القياسيّة التي لم تسنح لنا فرصة تعلّمها في كتابنا :
\InlineCode{toupper()}.
هذه الدالّة تحوّل الحرف المعطى إلى كبير
(\textenglish{Uppercase}).
هكّذا، اللعبة ستعمل حتى إن أدخل اللاعب حروفاً صغيرة. يجب تضمين
\InlineCode{ctype.h}
لتستطيع استخدام هذه الدالة (لا تنس ذلك !).

تأتي بعد ذلك المرحلة الأكثر أهمية : و هي أن نقوم بمسح المحارف التي يمكن أن نكون قد أدخلناها. في الواقع، بإعادة استدعاء
\InlineCode{getchar}
نحصل على المحرف الثاني الّذي تمّ إدخاله (مثلا
\InlineCode{\textbackslash n}).\\
ما أقوم به بسيط و يأخذ سطرا واحدا : أستدعي الدالة
\InlineCode{getchar}
في حلقة تكرارية حتى الوصول إلى
\InlineCode{\textbackslash n}.
تتوقف الحلقة إذن، و هذا يعني أننا "قرأنا" كلّ المحارف الأخرى، سيتمّ إذن إفراغها من الذاكرة. نقول أنّنا
\textbf{نفرغ المتغير المؤقت
(\textenglish{Buffer})}.

\begin{question}
لماذا توجد فاصلة منقوطة في نهاية الـ\InlineCode{while}
و لماذا لا نرى أية حاضنة ؟
\end{question}

في الواقع، استعملت حلقة تكرارية لا تحتوي على تعليمات (التعليمة الوحيدة، هي
\InlineCode{getchar}
داخل القوسين). الحاضنتان ليستا ضروريّتين نظرا لأنه ليس لدينا ما نفعله غير
\InlineCode{getchar}.
لهذا أضع فاصلة منقوطة لتعويض الحاضنتين. هذه الفاصلة المنقوطة تعني "لا تفعل شيئاً في كلّ دورة للحلقة". هذا أمر غريب قليلا، لكنها تقنيّة يجب معرفتها، تقنيّة يستعملها المبرمجون لانشاء حلقات بسيطة و قصيرة.

اعلم أنّ الـ\InlineCode{while}
كان بالإمكان كتابتها هكذا :

\begin{Csource}
while (getchar() != '\n')
{

}
\end{Csource}

لا يوجد شيء داخل الحاضنتين، إنّها تطوّعيّة، نظرا لأنّه ليس هناك شيء آخر لفعله. تقنيّتي الّتي تقتضي وضع فاصلة منقوطة فقط أبسط من تلك الخاصّة بالحاضنتين.

أخيرا، تقوم الدالة
\InlineCode{readCharacter}
بإرجاع المحرف الأوّل الذي قمنا بقراءته : المتغيّر
\InlineCode{character}.

خلاصة القول، في شفرتك، لا تستعمل :

\begin{Csource}
scanf("%c", &myLetter);
\end{Csource}

و إنما استعمل بدل ذلك دالّتنا الرائعة :

\begin{Csource}
myLetter = readCharacter();
\end{Csource}

\subsection{قاموس الكلمات}
لتجربة أولية للشفرة الخاصة بك، أطلب منك أن تقوم بتثبيت الكلمة السريّة مباشرة في الشفرة. أكتب مثلا :

\begin{Csource}
char secretWord[] = "RED";
\end{Csource}

طبعا ستبقى الكلمة السريّة نفسها دائما إن تركناها هكذا، هذا ليس ممتعا. لكني طلبت منك فعل ذلك لكي لا تخلط المشاكل. في الواقع، عندما تعمل لعبة
\textenglish{Pendu}
جيّدا (و فقط ابتداء من هذه اللحظة)، يمكنك البدء بالطور الثاني : إنشاء قاموس الكلمات.

\begin{question}
ما هو هذا "قاموس الكلمات" ؟
\end{question}

هو ملف يحتوي كثيرا من الكلمات للعبتك
\textenglish{Pendu}.
يجب أن تكون كل كلمة على سطر. مثلا :

\begin{Console}
HOUSE
BLUE
AIRPLANE
XYLOPHONE
BEE
BUILDING
WEIGHT
SNOW
ZERO
\end{Console}

في كل جولة جديدة، يجب على برنامجك أن يفتح الملف، و يأخذ كلمة عشوائية من القائمة. بفضل هذه الطريقة، سيكون لديك ملف يمكنك التعديل عليه كلّما أردت من أجل إضافة كلمات سريّة ممكنة من أجل
\textenglish{Pendu}.

\begin{information}
ستلاحظ أنني منذ البداية تعمّدت كتابة كلّ الكلمات بالحروف الكبيرة. في الواقع، في الـ\textenglish{Pendu}
لا يتم التمييز بين الحروف الكبيرة و الحروف الصغيرة، و لهذا فمن المستحسن أن نقول منذ البداية : "كل حروف كلمات اللعبة كبيرة". عليك أن تنبّه اللاعب، في دليل استخدام اللعبة مثلا، أنه يفترض به إدخال حروف كبيرة لا صغيرة.\\
بالمقابل، نتعمّد تجنب العلامات الصوتية
(\textenglish{accents})
لتبسيط اللعبة (إن بدأنا اختبار \textenglish{é}، \textenglish{è}، \textenglish{ê}، \textenglish{ë}... فلن ننتهي أبداً !). عليك إذن أن تكتب كلماتك كلّها بحروف كبيرة و بدون علامات صوتيّة.
\end{information}

المشكل الذي سيحدث لك سريعا هو أنه عليك معرفة عدد الكلمات الموجودة في القاموس. في الواقع، إن أردت إختيار كلمة عشوائية، يجب أن يتم أخذ عدد بين 0 و
\textenglish{X}،
و أنت لا تعرف في بادئ الأمر كم من الكلمات يحتوي الملف.

لحلّ هذا المشكل، يوجد حلّان. يمكنك أن تشير في السطر الأول من الملفّ إلى عدد الكلمات الّتي يحويها :

\begin{Console}
3
HOUSE
BLUE
AIRPLANE
\end{Console}

إلا أن هذه الطريقة مملة، لأنه يجب إعادة حساب عدد الكلمات يدويا في كلّ مرّة تضيف فيها كلمة (أو إضافة 1 إلى هذا العدد إن كنت ماكرا بدل إعادة الحساب، لكنّها تبقى طريقة بدائيّة قليلا). لهذا، أقترح عليك أن تعدّ تلقائيّا عدد الكلمات عن طريق قراءة الملف مرّة أولى باستخدام برنامجك. معرفة كم يوجد من كلمات أمر بسيط : عليك عدّ الـ\InlineCode{\textbackslash n}
(العودة إلى السطر) في الملف.

حينما تقرأ الملفّ في مرّة أولى لعدّ
\InlineCode{\textbackslash n}،
فعليك القيام بـ\InlineCode{rewind}
للعودة إلى البداية. لن يكون عليك إذن سوى أخذ عدد عشوائيّ بين عدد الكلمات الّتي عددتها، ثمّ عليك تخزين هذه الكلمة في سلسلة محرفيّة في الذاكرة.

سأتركك قليلا لتفكّر في كلّ هذا، لن أساعدك أكثر، و إلّا فلن يكون عملا تطبيقيا ! و اعلم بأن  كلّ المعارف الّتي تحتاجها موجودة في الفصول السابقة، فأنت قادر تماما على إنشاء هذه اللعبة. إنه يتطلّب منك بعض الوقت و هو أقلّ سهولة ممّا يبدو عليه، و لكن إذا نظّمت الأمور جيّدا (بإنشاء قدر كاف من الدوال) سوف تصل.

بالتوفيق !

\section{التصحيح (1 : شفرة اللعبة)}
بقراءتك لهذه السطور، يعني أنك قد أكملت البرنامج، أو أنك لم تستطع إكماله.

لقد استغرقت شخصيّا وقتا أكبر ممّا كنت أعتقد في إنشاء هذه اللعبة البسيطة للغاية. هكذا دائما : نقول "هذا بسيط"، لكن في الحقيقة توجد الكثير من الحالات لدراستها.

رغم ذلك أصرّ على القول بأنك قادر على فعل هذا. يلزمك فقط بعض الوقت (بضع دقائق، بضع ساعات بضع أيام ؟)، لكنّنا لم نكن أبدا في سباق. أنا أفضّل أن تأخذ كثيرا من الوقت للوصول إلى الحل على ألّا تجرّب سوى 5 دقائق و ترى التصحيح.

لا تعتقد أنّي كتبت البرنامج من المحاولة الأولى. أنا أيضا، كنت أعمل خطوة بخطوة. بدأت بشيء بسيط جدّا، ثمّ شيئا فشيئا حسّنت الشفرة للوصول إلى النتيجة النهائيّة.\\
قمت بعدّة أخطاء أثناء كتابة الشفرة : نسيت في لحظة ما تهيئة متغير بشكل صحيح، نسيت كتابة نموذج دالة و كذلك حذف متغير لم يعد مفيدا في شفرتي. و حتى أنّي -أعترف- نسيت فاصلة منقوطة سخيفة في لحظة ما عند نهاية تعليمة.

لماذا أقول كل هذا ؟ لكي أخبرك أنّني لست معصوما من الأخطاء و أنّي أواجه تقريبا نفس المشاكل مثلك
("\textit{أيّها البرنامج البائس، هل ستعمل أم لا !؟}").

سأعرض عليك الحلّ على جزئين.
\begin{itemize}
  \item أوّلا سأريك كيف أنشأت شفرة اللعبة نفسها، بتثبيت الكلمة المخفيّة مباشرة في الشفرة. إخترت الكلمة
\textenglish{YELLOW}
لأنّها تسمح باختبار ما إن كنت تعاملت جيّدا مع المحارف المتكرّرة.
  \item يعد ذلك، سأريك كيف أضفت العمل بقاموس الكلمات لأخذ كلمة سرّية عشوائيّة لللاعب.
\end{itemize}

بالطبع، يمكنني أن أريك الشفرة دفعة واحدة و لكن... سيكون هذا كثيرا في مرّة واحدة، و البعض لن تكون لديه الشجاعة لمحاولة فهم الشفرة.

سأحاول أن أشرح لك خطوة بخطوة طريقة عملي. تذكّر أنّ ما يهم، ليس النتيجة، و إنّما طريقة التفكير.

\subsection{تحليل الدالة
\texttt{main}}
مثلما يعلم الجميع، كلّ شيء يبدأ بـ\InlineCode{main}.
بجب ألا ننسى تضمين المكتبات
\InlineCode{stdio}،
\InlineCode{stdlib}
و
\InlineCode{ctype}
(من أجل الدالة
\InlineCode{toupper})
الّتي سنحتاج إليها أيضا :

\begin{Csource}
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

int main(int argc, char* argv[])
{
  return 0;
}
\end{Csource}

حسنا، لحدّ الآن يجب على الجميع أن يتابعوا.\\
الدالة
\InlineCode{main}
ستشكّل معظم اللعبة و ستقوم باستدعاء بعض الدوال حينما تحتاج إليها.

فلنبدأ بتعريف المتغيرات الضروريّة. كن متأكّدا، لم أفكّر في كلّ هذه المتغيرات من الوهلة الأولى، و لقد كان هناك أقلّ من هذا العدد في أوّل مرّة كتبت فيها الشفرة !

\begin{Csource}
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
int main(int argc, char* argv[])
{
  char letter = 0; // Stores the letter suggested by the user
  char secretWord[] = "YELLOW"; // The word that the user must find
  int foundLetter[3] = {0}; // Boolean table. Each cell corresponds to a letter in the secret word. 0 = letter not found, 1 = letter found
  int remainingTries = 10; // Counting the remaining tries (0 = dead)
  int i = 0; // A little variable to browse the table
  return 0;
}
\end{Csource}

لقد كتبت بمحض إرادتي تصريح كلّ متغير على سطر و وضعت كثيرا من التعليقات لشرح دور كل متغير. عمليّا، لست مضطرّا على وضع كلّ هذه التعليقات كما وضع الكثير من التصريحات في نفس السطر.

أعتقد أن أغلب المتغيرات تبدوا منطقية : المتغير
\InlineCode{letter}
يخزّن الحرف الذي يدخله المستخدم في كلّ مرة،
\InlineCode{secretWord}
يحوي الكلمة الواجب اكتشافها.
\InlineCode{remainingTries}
يحتوي عدد المحاولات المتبقّية، إلخ. المتغيّر
\InlineCode{i}
هو متغير صغير استعمله كي أتصفّح الجدول مستعملا الحلقة
\InlineCode{for}.
فهو ليس مهمّا جدّا لكنّه ضروريّ إذا أردنا القيام بحلقات.

و أخيراً المتغير الّذي يجب التفكير فيه، و الذي سيُمثّل الفرق، إنّه عبارة عن جدول من القيم المنطقية
\InlineCode{foundLetter}.
ستلاحظ بأنّي جعلت حجم الجدول يساوي عدد حروف الكلمة السريّة (6). هذا ليس أمراً عشوائياً : إذ أن كلّ خانة من جدول القيم المنطقية  تمثّل حرفاً من الكلمة السرية. هكذا، الخانة الأولى تمثّل الحرف الأوّل، الثانية الحرف الثاني، إلخ.\\
كلّ خانات الجدول مهيّئة في البداية على 0، و التي تعني "الحرف لم يتم إيجاده بعد". بتقدّم اللعبة، الجدول سيتمّ تعديله. من أجل كلّ حرف تمّ إيجاده من الكلمة، الخانة التي توافقها من
\InlineCode{foundLetter}
ستأخذ 1.

مثلا، إذا كان في مرحلة من الجولة، لدينا العرض
\textenglish{Y*LL*W}،
فإن جدول الـ\InlineCode{int}
سيحوي القيم : 101101 (1 لكل حرف تمّ إيجاده).\\
هذه الطريقة تسهّل علينا معرفة متى يربح اللاعب : يكفي التحقّق من أن جميع خانات الجدول لا تحوي سوى 1.\\
في الحالة الأخرى، سيخسر اللاعب إذا وصل العدّاد
\InlineCode{remainingTries}
إلى 0.

فلننتقل إلى التالي :

\begin{Csource}
printf("Welcome !\n\n");
\end{Csource}

هذه رسالة ترحيب، لا يوجد أي شيء مثير فيها. بالمقابل، الحلقة الرئيسيّة هي  الأكثر أهميّة :

\begin{Csource}
while (remainingTries  > 0 && !win(foundLetter))
{
\end{Csource}

اللعبة تستمرّ مادام قد بقي بعض المحاولات
(\InlineCode{remainingTries > 0})
و اللاعب لم يربح.\\
إذا لم تبق له أية محاولة، فهذا يعني أنه فشل. إن ربح، فهذا يعني... أنّه ربح.في كلتا الحالتين، يجب إيقاف اللعبة، أي إيقاف الحلقة التي تطلب قراءة حرف في كلّ مرة.

\InlineCode{win}
هي دالة تقوم بتحليل الجدول
\InlineCode{foundLetter}.
تقوم بإعادة "صحيح" (1) إذا كان اللاعب قد ربح (أي أن الجدول
\InlineCode{foundLetter}
لا يحمل سوى 1)، "خطأ" (0) إن كان لم يربح بعد.
لن أشرح لك الآن عمل الدالة بشكل مفصل، سنرى ذلك لاحقاً. حاليّا، يجب عليك فقط معرفة ما تفعله.

باقي الشفرة :

\begin{Csource}
printf("\n\nYou have %d remaining tries", remainingTries);
printf("\nWhat's the secret word ? ");
for (i = 0 ; i < 3 ; i++)
{
  if (foundLetter[i]) // If the letter n° i has been found
    printf("%c", secretWord[i]); // Display it
  else
    printf("*"); // Else, display * for the letters that are not found
}
\end{Csource}

نقوم في كل مرة بإظهار عدد المحاولات المتبقّية و كذا الكلمة السريّة (مخفيّة بـ* بالنسبة للحروف التي لم يتمّ إيجادها).\\
يتم إظهار الكلمة السريّة المخفيّة بـ* بفضل حلقة
\InlineCode{for}
حيث أننا نحلّل كلّ حرف لنرى إن تمّ إيجاده
(\InlineCode{if(foundLetter[i])}).
إن كان الشرط محققاً، سنظهر الحرف، و إلا سنظهر * لإخفاءه.

الآن بعدما أظهرنا ما يجب، سنطلب من اللاعب أن يدخل حرفاً جديداً :

\begin{Csource}
printf("\nSuggest a letter : ");
letter = readCharacter();
\end{Csource}

أستدعي دالتنا
\InlineCode{readCharacter()}.
هذه الدالة تقرأ الحرف الأول الذي تمّ إدخاله، تجعله  كبيراً ثم تفرّغ المتغير المؤقّت، أي أنّها تمسح بقيّة الحروف التي يمكن أن تبقى في الذاكرة.

\begin{Csource}
// if it's NOT the right letter
if (!findLetter(letter, secretWord, foundLetter))
  {
    remainingTries--; // Decrement the remaining tries
  }
}
\end{Csource}

نختبر ما إن كان الحرف الذي تمّ إدخاله موجودا في
\InlineCode{secretWord}.
نستدعي لأجل هذا دالّة أنشأناها تسمّى
\InlineCode{findLetter}.
سنرى بعد قليل شفرة هذه الدالّة.\\
حاليّا، كلّ ما يجب أن تعرفه، هو أنّ هذه الدالّة تعيد "صحيح" إن كان الحرف موجودا في الكلمة، "خطأ" إن لم تجده.

كما تلاحظ فالـ\InlineCode{if}
يبدأ بعلامة تعجّب ! و التي تعني "لا". الشرط يُقرأ إذن بهذه الطريقة : "إذا لم يتم إيجاد الحرف".\\
ماذا نفعل في حالة عدم إيجاد الحرف ؟ نقوم بتقليل عدد المحاولات المتبقية.

\begin{information}
لاحظ أيضاً أن الدالة
\InlineCode{findLetter}
تقوم بتحديث قيم الجدول
\InlineCode{foundLetter}.
تقوم بوضع 1 في الخانات الموافقة للحروف التي تمّ إيجادها.
\end{information}

الحلقة الرئيسية في اللعبة تتوقف هنا. لهذا فسنعيد من بداية الحلقة و نختبر ما إن كان قد بقي شيء من المحاولات للعب و اللاعب لم بربح بعد.

عند الخروج من الحلقة الرئيسيّة، لا يبقى سوى إظهار إن كان اللاعب قد نجح في اللعبة أو خسر قبل إنهاء البرنامج :

\begin{Csource}
if (win(foundLetter))
	printf("\n\nYou win! the secret word is : %s", secretWord );
else
	printf("\n\nYou lose ! the secret word is : %s", secretWord );
return 0;
}
\end{Csource}

سنستدعي الدالة
\InlineCode{win}
لنرى ما إن كان اللاعب قد ربح. إن كانت هذه هي الحالة، نقوم بإظهار الرسالة "ربح !"، و إلّا، فقد انتهت فرص اللعب، فقد خسر.

\subsection{تحليل الدالة
\texttt{win}}
فلنرى الآن الشفرة الخاصة بالدالة
\InlineCode{win} :

\begin{Csource}
int win(int foundLetter[])
{
  int i = 0;
  int playerWins = 1;
  for (i = 0 ; i < 3 ; i++)
  {
    if (foundLetter[i] == 0)
    playerWins = 0;
  }
  return playerWins;
}
\end{Csource}

هذه الدالة تأخذ جدول القيم المنطقيّة
\InlineCode{foundLetter}
كمعامل. تعيد قيمة منطقية : "صحيح" إذا ربح اللاعب و "خطأ" إذا خسِر.

الشفرة الخاصة بهذه الدالة بسيطة، بفترض بك فهمها. نتصفّح
\InlineCode{foundLetter}
و نختبر ما إن كانت
\underline{إحدى}
خانات الجدول تحوي "خطأ" (0). إن كان هناك حرف واحد لم يتمّ إيجاده فلقد خسر اللاعب : سيتم وضع "خطأ" (0) في المتغير المنطقي
\InlineCode{playerWins}.
و إلّا، إن تمّ إيجاد كل الحروف، فالمتغيّر المنطقي سيكون "صحيح" (1) و الدالة تعيد "صحيح".

\subsection{تحليل الدالة
\texttt{findLetter}}
لهذه الدالة مهمّتان :
\begin{itemize}
  \item إرجاع متغير منطقي يشير ما إن كان الحرف موجوداً في الكلمة السرية.
  \item تحديث (على 1) خانات الجدول
\InlineCode{foundLetter}
في المواضع الموافقة للحرف الذي تمّ إيجاده.
\end{itemize}

\begin{Csource}
int findLetter(char letter, char secretWord[], int foundLetter[])
{
  int i = 0;
  int rightLetter = 0;
  // Search for the letter in the table foundLetter
  for (i = 0 ; secretWord[i] != '\0' ; i++)
  {
    if (letter == secretWord[i]) // If it exists
    {
      rightLetter = 1; // Memorize that it was the right one
      foundLetter[i] = 1; // Put the correspondent value to 1 in the table
    }
  }
  return rightLetter ;
}
\end{Csource}

نتصفّح إذن السلسلة المحرفيّة
\InlineCode{secretWord}
محرفاً محرفاً. في كلّ مرّة، نختبر ما إن كان الحرف الذي اقترحه اللاعب حرف من الكلمة، سيتم القيام بأمرين :
\begin{itemize}
  \item تعديل المتغير المنطقي
\InlineCode{rightLetter}،
إلى  1، لكي تعيد الدالّة 1 لأن الحرف متواجد بالفعل في
\InlineCode{secretWord}.
  \item تحديث الجدول
\InlineCode{foundLetter}
على الموضع الحالي للإشارة إلى أنّ هذا الحرف قد تمّ إيجاده.
\end{itemize}

الشيء الجيّد في هذه الطريقة، هو أننا سنتصفّح كلّ الجدول (لا نتوقف عند أول حرف تم إيجاده). هذا سيسمح لنا بتحديث الجدول
\InlineCode{foundLetter}
بشكل صحيح، في الحالة التي تحتوي فيها الكلمة حرفاً مكرراً عدّة مرّات، مثل حالة
\textenglish{L}
في
\textenglish{YELLOW}.

\section{التصحيح (2 : استعمال قاموس الكلمات)}
لقد قمنا بجولة حول الوضائف الأساسيّة لبرنامجنا. إنّه يحتوي على كلّ ماهو ضروري لإدارة جولة في اللعبة، لكنه لا يعرف كيف يختار كلمة عشوائية من قاموس كلمات. لم أضع لك شفرة المرحلة الأولى كلّها لأنها كانت ستأخذ حجماً كبيراً كما ستكون تكرارا مع الشفرة المصدريّة النهائيّة الّتي ستراها فيما بعد.

قبل الذهاب بعيدا، الشيء الأوّل الواجب فعله هو إنشاء قاموس الكلمات. و حتى إن كان قصيراً فهذا ليس سيّئا، سيكون مناسبا للاختبارات.

سأقوم إذن بإنشاء ملف
\InlineCode{dico.txt}
\textbf{في نفس دليل مشروعي}.
حاليّا، سأضع فيه الكلمات التالية :

\begin{Csource}
HOUSE
BLUE
AIRPLANE
XYLOPHONE
BEE
BUILDING
WEIGHT
SNOW
ZERO
\end{Csource}

ما إن أنتهي من كتابة البرنامج، سأعود بالطبع إلى هذا القاموس و أملؤه بالكثير من الكلمات الغريبة كـ\textenglish{XYLOPHONE}
و المطوّلة كـ\textenglish{ANTIDISESTABLISHMENTARIANISM}.
لكن حاليّا، لنعد إلى كتابة التعليمات.

\subsection{تحضير الملفات الجديدة}

قراءة
"\textenglish{dico}"
سيأخذ الكثير من الأسطر (على الأقل، لديّ إحساس قبليّ بذلك). لهذا فسآخذ الاحتياطات بإضافة ملف آخر إلى مشروعي
\InlineCode{dico.c}
(الذي سيتكفّل بقراءة
\textenglish{dico}).
كما سنَقُوم بإنشاء
\InlineCode{dico.h}
الّذي يحوي نماذج الدوال الموجودة في
\InlineCode{dico.c}.

في
\InlineCode{dico.c}
سأبدأ بتضمين  المكتبات الّتي أنا في حاجة إليها بالإضافة إلى
\InlineCode{dico.h}.
أوّلا، كالعادة، سأحتاج إلى
\InlineCode{stdio.h}
و
\InlineCode{stdlib.h}
هنا. بالإضافة إلى هذا، يجب عليّ أن أقوم بسحب عشوائي لعدد من القاموس، سأقوم إذن بتضمين
\InlineCode{time.h}
مثلما فعلنا سابقاً من أجل العمل التطبيقي الأول "أكثر أو أقل".سأحتاج أيضا إلى تضمين
\InlineCode{string.h}
من أجل استعمال
\InlineCode{strlen}
في نهاية الدالّة.

\begin{Csource}
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>

#include "dico.h"
\end{Csource}
